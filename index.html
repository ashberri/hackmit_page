<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mobile Draggable Windows — MVP</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { --win: 18rem; }
    html, body { height: 100%; }
    /* Prevent page from rubber‑banding while dragging */
    .no-overscroll { overscroll-behavior: none; }
    /* Smooth, GPU-friendly movement */
    .dragging { transition: none !important; }
  </style>
</head>
<body class="no-overscroll bg-neutral-950 text-neutral-100 min-h-[100svh]">
  <header class="p-4 sticky top-0 bg-neutral-950/70 backdrop-blur z-50 flex items-center justify-between border-b border-white/10">
    <h1 class="font-semibold">Mobile Draggable Windows</h1>
    <button id="resetBtn" class="px-3 py-1.5 rounded-lg bg-neutral-800 hover:bg-neutral-700 text-sm">Reset</button>
  </header>

  <main id="canvas" class="relative h-[calc(100svh-56px)] touch-none select-none">
    <!-- Window template clones will land here -->
  </main>

  <template id="tpl">
    <section class="win absolute top-6 left-4 w-[min(86vw,380px)] max-w-[92vw] shadow-2xl rounded-2xl border border-white/10 bg-neutral-900/90 backdrop-blur transition-transform duration-200 will-change-transform">
      <header class="handle cursor-grab active:cursor-grabbing flex items-center gap-2 px-3 py-2 rounded-t-2xl bg-gradient-to-r from-fuchsia-600 to-indigo-600 text-white">
        <div class="w-2 h-2 rounded-full bg-white/80"></div>
        <h2 class="text-sm font-semibold grow truncate">Window</h2>
        <button class="minify text-xs bg-white/10 hover:bg-white/20 px-2 py-1 rounded-md">–</button>
      </header>
      <div class="content p-3 text-sm">
        <p class="opacity-90">Drag me by the top bar. Works with touch (Pointer Events) and mouse. Stays within screen bounds and remembers position.</p>
      </div>
    </section>
  </template>

  <script>
    /**
     * Mobile-first draggable windows using Pointer Events.
     * - Works on iOS Safari/Android Chrome/desktop.
     * - Drags only by the .handle to avoid scroll conflict.
     * - Constrains to viewport bounds.
     * - Brings active window to front (z-index stack).
     * - Persists positions in localStorage.
     */

    const Z_BASE = 10; let zTop = Z_BASE;
    const canvas = document.getElementById('canvas');
    const tpl = document.getElementById('tpl');

    const windowsData = [
      { id: 'win-topics', title: 'Topics', x: 16, y: 16, html: '<ul class="list-disc list-inside space-y-1"><li>Planning (42%)</li><li>Product (33%)</li><li>Team (18%)</li></ul>' },
      { id: 'win-highlights', title: 'Highlights', x: 120, y: 120, html: '<div class="space-y-1"><div>Longest: 4m12s</div><div>Peak Sentiment: High @ 23:17</div></div>' },
      { id: 'win-actions', title: 'Action Items', x: 40, y: 260, html: '<ol class="list-decimal list-inside space-y-1"><li>Ship UI prototype</li><li>Record demo</li><li>Sync with API</li></ol>' },
    ];

    // Restore persisted positions if any
    windowsData.forEach(w => {
      const saved = JSON.parse(localStorage.getItem(w.id) || 'null');
      if (saved && Number.isFinite(saved.x) && Number.isFinite(saved.y)) { w.x = saved.x; w.y = saved.y; }
    });

    // Create windows
    windowsData.forEach(w => createWindow(w));

    function createWindow({ id, title, x, y, html }) {
      const node = tpl.content.firstElementChild.cloneNode(true);
      node.dataset.id = id;
      node.style.transform = `translate(${x}px, ${y}px)`;
      node.style.zIndex = ++zTop;
      node.querySelector('h2').textContent = title;
      node.querySelector('.content').innerHTML = html;

      const handle = node.querySelector('.handle');
      const minBtn = node.querySelector('.minify');

      // Window state
      let startX = 0, startY = 0; // pointer start
      let winX = x, winY = y;     // current translate
      let dragging = false;

      // Pointer Events (unified for touch & mouse)
      handle.addEventListener('pointerdown', onPointerDown, { passive: false });
      handle.addEventListener('dblclick', () => toggleMinify(node));
      minBtn.addEventListener('click', () => toggleMinify(node));

      // Focus / raise on tap
      node.addEventListener('pointerdown', () => node.style.zIndex = ++zTop);

      function onPointerDown(e) {
        e.preventDefault(); // prevent page pan while dragging
        dragging = true;
        node.classList.add('dragging');
        startX = e.clientX; startY = e.clientY;
        // current translate from style
        const m = node.style.transform.match(/translate\(([-0-9.]+)px,\s*([-0-9.]+)px\)/);
        if (m) { winX = parseFloat(m[1]); winY = parseFloat(m[2]); }
        node.setPointerCapture(e.pointerId);
        node.addEventListener('pointermove', onPointerMove, { passive: false });
        node.addEventListener('pointerup', onPointerUp, { passive: true, once: true });
        node.addEventListener('pointercancel', onPointerUp, { passive: true, once: true });
      }

      function onPointerMove(e) {
        if (!dragging) return;
        e.preventDefault();
        const dx = e.clientX - startX; const dy = e.clientY - startY;
        // Proposed new position
        let nx = winX + dx; let ny = winY + dy;
        const bounds = measureBounds(node);
        nx = Math.min(bounds.maxX, Math.max(bounds.minX, nx));
        ny = Math.min(bounds.maxY, Math.max(bounds.minY, ny));
        node.style.transform = `translate(${nx}px, ${ny}px)`;
      }

      function onPointerUp(e) {
        dragging = false; node.classList.remove('dragging');
        node.releasePointerCapture(e.pointerId);
        node.removeEventListener('pointermove', onPointerMove);
        // Persist
        const m = node.style.transform.match(/translate\(([-0-9.]+)px,\s*([-0-9.]+)px\)/);
        if (m) {
          localStorage.setItem(id, JSON.stringify({ x: parseFloat(m[1]), y: parseFloat(m[2]) }));
        }
      }

      canvas.appendChild(node);
    }

    function toggleMinify(node) {
      const body = node.querySelector('.content');
      const isHidden = body.classList.toggle('hidden');
      node.querySelector('.minify').textContent = isHidden ? '+' : '–';
    }

    function measureBounds(node) {
      // Keep the whole window inside the canvas
      const rect = canvas.getBoundingClientRect();
      const nrect = node.getBoundingClientRect();
      const pad = 8;
      const minX = pad - (nrect.left - parseFloat(getTranslate(node).x));
      const minY = pad - (nrect.top - parseFloat(getTranslate(node).y));
      const maxX = rect.width - nrect.width - pad - (nrect.left - parseFloat(getTranslate(node).x));
      const maxY = rect.height - nrect.height - pad - (nrect.top - parseFloat(getTranslate(node).y));
      return { minX, minY, maxX, maxY };
    }

    function getTranslate(el) {
      const m = el.style.transform.match(/translate\(([-0-9.]+)px,\s*([-0-9.]+)px\)/);
      return { x: m ? m[1] : 0, y: m ? m[2] : 0 };
    }

    // Reset positions
    document.getElementById('resetBtn').addEventListener('click', () => {
      windowsData.forEach(w => localStorage.removeItem(w.id));
      location.reload();
    });

    // Resize handling: nudge windows back into view if the keyboard/notch changes safe area
    window.addEventListener('resize', () => {
      document.querySelectorAll('.win').forEach(node => {
        const bounds = measureBounds(node);
        const pos = getTranslate(node);
        let nx = Math.min(bounds.maxX, Math.max(bounds.minX, parseFloat(pos.x)));
        let ny = Math.min(bounds.maxY, Math.max(bounds.minY, parseFloat(pos.y)));
        node.style.transform = `translate(${nx}px, ${ny}px)`;
      });
    });
  </script>
</body>
</html>

